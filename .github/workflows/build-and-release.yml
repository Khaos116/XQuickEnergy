name: Build and Release

on:
  workflow_dispatch:  # 手动触发工作流

jobs:
  check_version:
    runs-on: ubuntu-latest

    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 拉取所有标签和完整历史

      - name: 获取最新发布版本标签
        id: get_release_tag
        run: |
          RESPONSE=$(curl --silent "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          RELEASE_TAG=$(echo "${RESPONSE}" | jq -r .tag_name)
          echo "最新发布的版本标签: ${RELEASE_TAG}"
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV  # 设置环境变量

      - name: 获取 myLazyNoSo 分支的最新标签
        id: get_my_lazy_tag
        run: |
          git fetch --tags  # 确保获取所有标签
          TAGS=$(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | grep -E '^v' | head -n 1)
          echo "myLazyNoSo 分支的最新标签: ${TAGS}"
          echo "TAGS=${TAGS}" >> $GITHUB_ENV  # 设置环境变量

      - name: 比较版本标签
        id: compare_versions
        run: |
          echo "比较版本: RELEASE_TAG=${{ env.RELEASE_TAG }}, TAGS=${{ env.TAGS }}"
          if [[ "${{ env.RELEASE_TAG }}" != "${{ env.TAGS }}" ]]; then
            echo "版本不同: 发布版本标签 (${{ env.RELEASE_TAG }}) 和 myLazyNoSo 分支标签 (${{ env.TAGS }}) 不同，开始打包"
            echo "should_build=true" >> $GITHUB_ENV
          else
            echo "版本相同: 发布版本标签 (${{ env.RELEASE_TAG }}) 和 myLazyNoSo 分支标签 (${{ env.TAGS }}) 相同，无需发版"
            echo "should_build=false" >> $GITHUB_ENV
          fi

#      - name: 获取更新日志
#        if: env.should_build == 'true'
#        id: get_changelog
#        run: |
#          # 获取两个标签之间的提交日志
#          CHANGELOG=$(git log ${{ env.RELEASE_TAG }}..${{ env.TAGS }} --pretty=format:"%s")
#
#          # 处理更新日志
#          PROCESSED_CHANGELOG=""
#          INDEX=1
#
#          # 遍历每条日志
#          while IFS= read -r entry; do
#            # 检查日志是否包含中文
#            if [[ "$entry" =~ [\u4e00-\u9fa5] ]]; then
#              # 去除 * 字符
#              entry=$(echo "$entry" | sed 's/\*//g')
#              PROCESSED_CHANGELOG+="$INDEX. $entry\n"
#              INDEX=$((INDEX + 1))
#            fi
#          done <<< "$CHANGELOG"
#
#          # 输出处理后的更新日志
#          echo -e "处理后的更新日志:\n$PROCESSED_CHANGELOG"
#          echo "CHANGELOG=$PROCESSED_CHANGELOG" >> $GITHUB_ENV  # 将处理后的日志存储为环境变量

      - name: 获取更新日志
        if: env.should_build == 'true'
        id: get_changelog
        run: |
          # 获取两个标签之间的提交日志
          CHANGELOG=$(git log ${{ env.RELEASE_TAG }}..${{ env.TAGS }} --pretty=format:"%s")

          # 临时文件用于存储中文日志
          TEMP_LOG_FILE=$(mktemp)

          # 遍历每条日志
          while IFS= read -r entry; do
            # 使用 grep 来检查日志中是否包含中文字符
            if echo "$entry" | grep -Pq '[\x{4e00}-\x{9fa5}]'; then
              # 去除 * 字符并保存到临时文件
              entry=$(echo "$entry" | sed 's/\*//g')
              echo "$entry" >> "$TEMP_LOG_FILE"
            fi
          done <<< "$CHANGELOG"

          # 去重：排序并去除重复的日志条目
          SORTED_UNIQUE_CHANGELOG=$(sort "$TEMP_LOG_FILE" | uniq)

          # 将去重后的日志条目格式化并存储到 PROCESSED_CHANGELOG 变量
          PROCESSED_CHANGELOG=""
          INDEX=1
          while IFS= read -r unique_entry; do
            PROCESSED_CHANGELOG+="$INDEX. $unique_entry\n"
            INDEX=$((INDEX + 1))
          done <<< "$SORTED_UNIQUE_CHANGELOG"

          # 输出处理后的更新日志
          echo -e "处理后的更新日志:\n$PROCESSED_CHANGELOG"
          echo "CHANGELOG=$PROCESSED_CHANGELOG" >> $GITHUB_ENV  # 将处理后的日志存储为环境变量
      
      

      # 检查 JDK 是否已安装
      - name: 检查 JDK 是否已安装
        id: check_jdk
        run: |
          if java -version &>/dev/null; then
            echo "JDK 已安装"
            echo "jdk_installed=true" >> $GITHUB_ENV
          else
            echo "JDK 未安装"
            echo "jdk_installed=false" >> $GITHUB_ENV
          fi

      # 检查 Gradle 是否已安装
      - name: 检查 Gradle 是否已安装
        id: check_gradle
        run: |
          if ./gradlew -v &>/dev/null; then
            echo "Gradle 已安装"
            echo "gradle_installed=true" >> $GITHUB_ENV
          else
            echo "Gradle 未安装"
            echo "gradle_installed=false" >> $GITHUB_ENV
          fi

      # 缓存 JDK
      - name: 缓存 JDK
        if: env.jdk_installed == 'false'
        uses: actions/cache@v3
        with:
          path: ~/.sdkman/candidates
          key: ${{ runner.os }}-jdk-11-${{ hashFiles('**/build.gradle*') }}
          restore-keys: |
            ${{ runner.os }}-jdk-11-

      # 缓存 Gradle
      - name: 缓存 Gradle
        if: env.gradle_installed == 'false'
        uses: actions/cache@v3
        with:
          path: ~/.gradle
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: 安装 JDK 11
        if: env.jdk_installed == 'false' && env.should_build == 'true'
        run: |
          sudo apt update
          sudo apt install -y openjdk-11-jdk

      - name: 验证 JDK 安装
        if: env.should_build == 'true'
        run: |
          java -version

      # 设置 gradlew 可执行权限
      - name: 设置 gradlew 可执行权限
        run: |
          chmod +x ./gradlew

      # 使用 Gradle Wrapper 构建
      - name: 使用 Gradle Wrapper 构建
        if: env.should_build == 'true'
        run: |
#          ./gradlew clean assembleCompatibleRelease

      - name: 延迟等待文件生成
        if: env.should_build == 'true'
        run: |
          echo "等待 5 秒以确保 APK 文件生成完成..."
          sleep 5  # 延迟 5 秒

      - name: 检查 APK 文件是否存在
        if: env.should_build == 'true'
        run: |
          APK_FILE=$(ls build/outputs/apk/compatible/release/*.apk | head -n 1)
          if [[ -z "$APK_FILE" ]]; then
            echo "未找到 APK 文件，构建可能未成功"
            exit 1
          else
            echo "找到 APK 文件: $APK_FILE"
            echo "APK_FILE=$APK_FILE" >> $GITHUB_ENV
          fi

      - name: 发布到 GitHub
        if: env.should_build == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "XQE_lazy_${{ env.TAGS }}"  # 自定义发布标题
          body: ${{ env.CHANGELOG }}  # 更新日志
          files: ${{ env.APK_FILE }}  # 发布最新的 APK 文件
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
