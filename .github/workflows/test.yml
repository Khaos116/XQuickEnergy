name: Build And Publish APK

on:
  workflow_dispatch:  # 手动触发工作流

permissions: #发布到github需要
  contents: write
  actions: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 拉取所有标签和完整历史
        env:
          GIT_TERMINAL_PROMPT: 0  # 禁用 Git 终端提示，避免冗余输出
          GIT_SSH_COMMAND: "ssh -o LogLevel=QUIET"  # 禁用 SSH 日志输出

      - name: 获取最新发布版本标签
        id: get_release_tag
        run: |
          RESPONSE=$(curl --silent "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          RELEASE_TAG=$(echo "${RESPONSE}" | jq -r .tag_name)
          echo "最新发布的版本标签: ${RELEASE_TAG}"
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV  # 设置环境变量

      - name: 获取 myLazyNoSo 分支的最新标签
        id: get_my_lazy_tag
        run: |
          git fetch --tags  # 确保获取所有标签
          TAGS=$(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | grep -E '^v' | head -n 1)
          echo "myLazyNoSo 分支的最新标签: ${TAGS}"
          echo "TAGS=${TAGS}" >> $GITHUB_ENV  # 设置环境变量

      - name: 比较版本标签
        id: compare_versions
        run: |
          echo "比较版本: RELEASE_TAG=${{ env.RELEASE_TAG }}, TAGS=${{ env.TAGS }}"
          if [[ "${{ env.RELEASE_TAG }}" != "${{ env.TAGS }}" ]]; then
            echo "版本不同: 发布版本标签 (${{ env.RELEASE_TAG }}) 和 myLazyNoSo 分支标签 (${{ env.TAGS }}) 不同，继续执行"
            echo "should_build=true" >> $GITHUB_ENV
          else
            echo "版本相同: 发布版本标签 (${{ env.RELEASE_TAG }}) 和 myLazyNoSo 分支标签 (${{ env.TAGS }}) 相同，无需发版"
            echo "should_build=false" >> $GITHUB_ENV
          fi

      - name: 获取 ${{ env.RELEASE_TAG }} 和 ${{ env.TAGS }} 之间的提交日志
        if: env.should_build == 'true'
        id: get_changelog
        run: |
          # 获取两个标签之间的提交日志
          CHANGELOG=$(git log ${{ env.RELEASE_TAG }}..${{ env.TAGS }} --pretty=format:"%s")
          
          # 临时文件用于存储中文日志
          TEMP_LOG_FILE=$(mktemp)
          
          # 遍历每条日志
          while IFS= read -r entry; do
            # 使用 grep 来检查日志中是否包含中文字符
            if echo "$entry" | grep -Pq '[\x{4e00}-\x{9fa5}]'; then
              # 去除 * 字符并保存到临时文件
              entry=$(echo "$entry" | sed 's/\*//g')
              echo "$entry" >> "$TEMP_LOG_FILE"
            fi
          done <<< "$CHANGELOG"
          
          # 去重：排序并去除重复的日志条目
          SORTED_UNIQUE_CHANGELOG=$(sort "$TEMP_LOG_FILE" | uniq)
          
          # 将去重后的日志条目格式化并存储到 PROCESSED_CHANGELOG 变量
          PROCESSED_CHANGELOG=""
          INDEX=1
          while IFS= read -r unique_entry; do
            PROCESSED_CHANGELOG+="$INDEX. $unique_entry<br>"
            INDEX=$((INDEX + 1))
          done <<< "$SORTED_UNIQUE_CHANGELOG"
          
          # 输出处理后的更新日志
          echo -e "处理后的更新日志:\n$PROCESSED_CHANGELOG"
          echo "CHANGELOG=$PROCESSED_CHANGELOG" >> $GITHUB_ENV  # 将处理后的日志存储为环境变量

      - name: 检查 JDK 是否已安装
        id: check_jdk
        run: |
          if java -version &>/dev/null; then
            echo "JDK 已安装"
            echo "jdk_installed=true" >> $GITHUB_ENV
          else
            echo "JDK 未安装"
            echo "jdk_installed=false" >> $GITHUB_ENV
          fi

      - name: 安装 JDK 11
        if: env.jdk_installed == 'false'
        run: |
          sudo apt update
          sudo apt install -y openjdk-11-jdk

      - name: 验证 JDK 安装
        run: java -version

      - name: 下载并安装指定版本的 Gradle
        run: |
          GRADLE_VERSION=7.2
          wget https://services.gradle.org/distributions/gradle-${GRADLE_VERSION}-bin.zip
          unzip gradle-${GRADLE_VERSION}-bin.zip -d /opt/gradle
          echo "/opt/gradle/gradle-${GRADLE_VERSION}/bin" >> $GITHUB_PATH  # 添加到 PATH

      - name: 验证 Gradle 安装
        run: gradle -v

      - name: 设置 gradlew 可执行权限
        run: |
          chmod +x ./gradlew
          ls -l ./gradlew  # 检查文件权限，确认是否为可执行

      - name: 使用 Gradle Wrapper 构建
        if: env.should_build == 'true'
        run: |
          ./gradlew clean assembleCompatibleRelease

      - name: 延迟等待文件生成
        if: env.should_build == 'true'
        run: |
          echo "等待 5 秒以确保 APK 文件生成完成..."
          sleep 5  # 延迟 5 秒

      - name: 检查 APK 文件并重命名
        id: rename_apk
        run: |
          APK_DIR="app/build/outputs/apk/compatible/release"
          if [ -d "$APK_DIR" ] && ls "$APK_DIR"/*.apk 1> /dev/null 2>&1; then
            echo "找到 APK 文件，准备重命名最新的文件..."

            # 设置时区为 GMT+8
            export TZ="Asia/Shanghai"

            # 获取按时间倒序排列的最新 APK 文件
            LATEST_APK=$(ls -t "$APK_DIR"/*.apk | head -n 1)

            # 获取当前时间并格式化为 YYYYMMDD_HHMM (GMT+8)
            TIMESTAMP=$(date +"%Y%m%d_%H%M")

            # 生成新的文件名
            NEW_NAME="XQE_lazy_${TAGS}_${TIMESTAMP}.apk"

            # 重命名文件
            mv "$LATEST_APK" "$APK_DIR/$NEW_NAME"
            echo "重命名成功: $NEW_NAME"

            # 将重命名后的文件路径赋值给环境变量
            echo "APK_FILE=${APK_DIR}/${NEW_NAME}" >> $GITHUB_ENV
          else
            echo "没有找到 APK 文件或目录不存在"
            exit 1  # 退出并标记为失败
          fi

      - name: 设置 SSH 密钥
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: 发布到 GitHub
        if: env.should_build == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "XQE_lazy_${{ env.TAGS }}版"  # 自定义发布标题
          body: ${{ env.CHANGELOG }}  # 更新日志
          files: ${{ env.APK_FILE }}  # 发布最新的 APK 文件
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
